<!-- date: 2021-09-03 -->

# 什么是内存对齐？

为了能让 CPU 可以更快的存取到各个字段，Go 编译器会自动把 struct 结构体做数据对齐，所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便 CPU 可以一次将数据从内存中读取出来。编译器通过在结构体的各个字段之间填充一些空白来达到内存对齐的目的。

# 对齐系数

32 位系统对齐系数是 4；64 位系统对齐系数是 8。使用 `unsafe.Aligof` 函数可以查看相应类型的对齐系数。

# 优点

提高内存访问效率。32 位 CPU 一次可以从内存中读取 4 个字节的数据；64 位 CPU 一次可以从内存中读取 8 个字节的数据。如果所需的数据跨了 CPU 一次能读取的最大长度，那么就得花两个 CPU 周期的时间读取了。

# 缺点

空间换时间

# 结构体对齐

1. 结构体元素的存储地址和占用的字节数都要是它对齐边界的倍数（结构体元素存储地址 % 对齐边界 = 0）
2. 整个结构体内存占用字节数是类型对齐边界的倍数（结构体占用字节数 % 对齐边界 = 0）

```Go
type T struct {
    a int8 // 1 byte
    b int64 // 8 byte
    c int 32 // 4 byte
    d int16 // 2 byte
}
```

```txt
# 内存块
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

# 0%1=0 
addr 0: a

# 8%8=0
addr 8 ~ 15: b

# 16%4=0
addr 16 ~ 19: c

# 20%2=0
addr 20 ~ 21: d

# (21+3)%8=0
addr 0 ~ 24: T
```

# 总结

内存对齐可以提高 CPU 访问内存的效率。Go 编译器会根据 CPU 架构自动对结构体进行数据对齐，确保内存地址是所存储数据大小的整数倍。32 位 CPU 一次可以从内存中读取 4 个字节的数据；64 位 CPU 一次可以读取 8 个字节的数据；可以通过 `unsafe.Aligof` 函数获取基础数据类型的对齐边界。如果所需的数据跨了 CPU 一次能读取的最大长度，那么就得花两个 CPU 周期的时间读取了。
